[{"content":"Preface (just a shoutout) Firstly, before digging into the real meat of this post, I\u0026rsquo;d like to thank GuildDarts on GitHub for creating the incredible Docker Folders plugin for Unraid (which greatly helped me clean up my Docker container list). I found this plugin after creating a new IPFS Docker container, which rounded out a cluttered ~30 containers running on my Dell R620. With it, I was able to make a new Web3 category to store my new related containers in. Now I have 6 or so container categories, and it is much more readable.\nIPFS Introduction As described on their website, IPFS is:\n A peer-to-peer hypermedia protocol designed to preserve and grow humanity\u0026rsquo;s knowledge by making the web upgradeable, resilient, and more open.\n It\u0026rsquo;s a neat piece of software written in Go that is powering some of the early work in what the community is calling Web3. Essentially, IPFS is a distributed storage network, which allows access to data by any node on the network. By definition, it\u0026rsquo;s also decentralized. All the different pieces of data are spread out (distributed) across the network nodes.\nSo How Does It Work? I won\u0026rsquo;t pretend to understand the finer and more technical details of this project (yet), but their documentation (which coincedentally also uses IPFS to access) does an admirable job of summing up the three key points that make IPFS tick. They are as follows:\n Unique identification via content addressing Content linking via directed acyclic graphs (DAGs) Content discovery via distributed hash tables (DHTs)  You can also read more here.\nWhat Am I Doing Here? I\u0026rsquo;ve recently become interested in exploring Blockchain, Crypto, and Web3 topics, and I wanted to explore the process of purchasing a domain from the Ethereum Name Service (which can be used to send Ethereum directly to me). In addition, using the ContentHash record, I wanted to host a simple HTML website from it. Hosting a file with an ENS (Ethereum Name Service) address can leverage IPFS to permanently (as long as it\u0026rsquo;s shared) host a website. What\u0026rsquo;s neat about this process is that it\u0026rsquo;s completely resistant to censorship, whether it be from parents, coworkers, employers, or even government agencies. Yeah that\u0026rsquo;s right, come at me NSA! I mean business. I\u0026rsquo;m surely already on one of your lists (NSA labels Linux Journal readers and Tor and Tails users as extremists).\nHosting IPFS Container The IPFS Desktop app conveniently provides the ability to access the IPFS network on your own computer. It does pose a problem though for persisting information on the network. IPFS coins the term pinning to describe the process of preventing the IPFS Node\u0026rsquo;s garbage collector from removing a specific file or files. Using pinning on the Desktop version of IPFS is great, but it has one major downfall. If the file hasn\u0026rsquo;t been shared yet, when your computer turns off, it will disappear from the IPFS network. This is where Docker comes in! I was able to provision an IPFS Docker Node following the instructions on their documentation, which can be found here.\nIPFS on Docker Hints The IPFS Docker container requires one port to be forwarded (4001 TCP/UDP) and also requires passing port 5001 to access the WebUI. Once started, you\u0026rsquo;ll need to access the WebUI at the following address http://\u0026lt;container-ip-address\u0026gt;:5001/webui as the root (without webui) will return a 404. Then, it\u0026rsquo;s incredibly important to follow the instructions provided on the WebUI to gain access to the IPFS API (by default it has very strict CORS requirements).\nUploading HTML Website The next step was to create and upload my simple HTML website to IPFS. In the Web3 mindset, I didn\u0026rsquo;t want to rely on any Web2 (conventional) services for my site. With that, the font is included (courtesy of Google Fonts) and the HTML/CSS files have no external scripts or dependencies. After starting my Docker IPFS Node, I was ready to begin the upload process. The easiest way I have found is to use the IPFS Desktop App alongside the Docker container to provide permanent pinning (without the use of a pinning service like Piñata).\nMy website has multiple files (a font, a stylesheet, and the HTML document), so the easiest way to upload this to IPFS is with a folder. I went through this process using the Windows IPFS Desktop application. It\u0026rsquo;s a pretty straightforward process, and gives you the option to select specific files within the folder to include/exclude in the final hash. Once the uploading process completes, you\u0026rsquo;ll be provided with.\nFor my Mac/Linux friends out there, the CLI (Command Line Interface) method to upload multiple files is also shown on the IPFS Documentation. It also allows for passing in an ignore file (so that you can ignore .git/ and other files). I plan to explore the CLI interface in the future as I don\u0026rsquo;t like to rely on Desktop applications when there\u0026rsquo;s a suitable alternative available.\nUpdating ContentHash For an Ethereum Name Service domain, the method of attributing some piece of distributed content is by setting it in the ContentHash record. Currently, the whole process is quite expensive (purchasing, registering, and updating an ENS domain) as the Ethereum network is quite congested. You can check the current Ethereum Gas fee here on ethgas.watch. Throughout the process, I paid between $60 and $80 USD in transaction fees. Uh oh!\nOnce I was ready, I grabbed the CID of my folder (which is now stored on IPFS) and logged into the Ethereum Name Service\u0026rsquo;s domain configuration page. From there, you are able to set the Content value for your domain, which in my case was an IPFS link. I then confirmed the transaction and paid the gas fee to have this ContentHash added to the Ethereum Blockchain. Unfortunately, at the time I didn\u0026rsquo;t know that it\u0026rsquo;s a good idea to use the IPNS (InterPlanetary Name Service) address, which allows future updates to the content. An example of that process can be found here. For the time being, my website\u0026rsquo;s content is unmodifiable and connected to my ENS Address.\nAccessing New IPFS Content There are multiple ways to access the website now! Two links that should work in normal browsers are:\n https://alpin3.eth.link https://alpin3.eth.limo  The content is also accessible through IPFS at the link below:\n ipfs://QmS8FUArChXPQDfxeVTFU4Bnn48m4knMqxQ1GjrWB5RjMK  Final Notes This process has been a ton of fun to follow and learn about (except for those darn ⛽ fees) and I look forward to spending more time in the blockchain space in the future.\nHappy Hacking!\n","permalink":"https://michaelpeters.dev/posts/adventures-in-ipfs/","summary":"Preface (just a shoutout) Firstly, before digging into the real meat of this post, I\u0026rsquo;d like to thank GuildDarts on GitHub for creating the incredible Docker Folders plugin for Unraid (which greatly helped me clean up my Docker container list). I found this plugin after creating a new IPFS Docker container, which rounded out a cluttered ~30 containers running on my Dell R620. With it, I was able to make a new Web3 category to store my new related containers in.","title":"Adventures in IPFS"},{"content":"Issue This evening, I was struggling to access my new \u0026ldquo;7 Days To Die\u0026rdquo; server after provisioning a new Rocky Linux 8 VM to host it on. As a preface, I have plenty of experience hosting both bare-metal and VM game servers. For Steam games, my tool of choice is typically LinuxGSM by Daniel Gibbs. This is a fabulous piece of software that abstracts some of the nitty-gritty away (which definitely helps when running servers from multiple games).\nPort-Forwarding Normally, I would chalk a connection issue up to a misconfigured port forward. I quickly determined that another issue was at fault when I couldn\u0026rsquo;t access the server from the LAN. That is a telltale sign something else is at play.\nGoogle Searching After many dead ends, I stumbled upon this r/7daystodie thread where the OP noticed that there is a parameter in the settings file that prevents SteamNetworking from being enabled. I was dumbfounded that a default setting in the server config prevents networking/connection on the main platform of distribution.\nImportant Settings On line 15 of my configuration file (sdtdserver.xml), I removed SteamNetworking from the value field. This was based upon the suggestions from the above Reddit thread.\n\u0026lt;property name=\u0026#34;ServerDisabledNetworkProtocols\u0026#34; value=\u0026#34;SteamNetworking\u0026#34;/\u0026gt; \u0026lt;!-- Networking protocols that should not be used. Separated by comma. Possible values: LiteNetLib, SteamNetworking. Dedicated servers should disable SteamNetworking if there is no NAT router in between your users and the server or when port-forwarding is set up correctly --\u0026gt; Wrap-up I found that, when using a text-editor such as nano to edit the configuration file, the comment is obstructed which explains that SteamNetworking should be removed when \u0026ldquo;port-forwarding is set up correctly\u0026rdquo;. I would definitely say that this is user error, but from a developer side, it could definitely be more clear that this value needs to be modified before use (without relying on line-wrap). This value is easily missed and there is no emphasis or clarity that a server won\u0026rsquo;t be accessable unless you pay close attention to the configuration.\n","permalink":"https://michaelpeters.dev/posts/linuxgsm-7dtd-info/","summary":"Issue This evening, I was struggling to access my new \u0026ldquo;7 Days To Die\u0026rdquo; server after provisioning a new Rocky Linux 8 VM to host it on. As a preface, I have plenty of experience hosting both bare-metal and VM game servers. For Steam games, my tool of choice is typically LinuxGSM by Daniel Gibbs. This is a fabulous piece of software that abstracts some of the nitty-gritty away (which definitely helps when running servers from multiple games).","title":"LinuxGSM 7DaysToDie Tips"},{"content":"The Question? Should a software engineer use tabs or spaces when writing code?\nThe Answer? Use tabs, no really. In your favorite text-editor or IDE, simply set the tab length to 4 spaces.\nWhy?  Tabs take only one byte, whereas the equivalent (4 spaces) takes four bytes.  Realistically, this doesn\u0026rsquo;t matter nowadays with compression, minification, and large HDD/SSD storage mediums available.   Tabs allow you to set the visual-width to your liking.  Do you prefer 2 spaces or 8 spaces over the conventional 4 spaces? Change the default tab width and you\u0026rsquo;re off to the races.   Go and Python (my current go-to languages) enforce consistency and significantly favor tabs over spaces.  Example Program created with tabs!\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;errors\u0026#34; ) func main() { err := TabsAreSuperior(\u0026#34;tabs\u0026#34;) if err != nil { fmt.Println(err.Error()) } } func TabsAreSuperior(input string) error { switch input { case \u0026#34;tabs\u0026#34;: fmt.Println(\u0026#34;this is the way\u0026#34;) return nil case \u0026#34;spaces\u0026#34;: fmt.Println(\u0026#34;that\u0026#39;s not tabs\u0026#34;) return nil default: return errors.New(\u0026#34;please input either \u0026#39;tabs\u0026#39; or \u0026#39;spaces\u0026#39;\u0026#34;) } } ","permalink":"https://michaelpeters.dev/posts/spaces-vs-tabs/","summary":"The Question? Should a software engineer use tabs or spaces when writing code?\nThe Answer? Use tabs, no really. In your favorite text-editor or IDE, simply set the tab length to 4 spaces.\nWhy?  Tabs take only one byte, whereas the equivalent (4 spaces) takes four bytes.  Realistically, this doesn\u0026rsquo;t matter nowadays with compression, minification, and large HDD/SSD storage mediums available.   Tabs allow you to set the visual-width to your liking.","title":"Spaces vs. Tabs"}]